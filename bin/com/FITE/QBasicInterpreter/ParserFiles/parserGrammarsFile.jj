/**/options{  static = true;}/**/PARSER_BEGIN(parserGrammarsFile)package com.FITE.QBasicInterpreter.ParserFiles;/**/
import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.AbstractNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.AndNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.ArithmeticExpressionNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.ConstantNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.ElseNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.IfNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.PrintNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.RootParseTreeNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.StringNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.VariableNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.AssignmentNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.ConditionNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.InputNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.NotNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.OrNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.WhileNode;import com.FITE.QBasicInterpreter.ParseTreeNodeTypes.ForNode;import com.FITE.QBasicInterpreter.Tools.Context;import java.io.BufferedInputStream;import java.io.FileInputStream;import java.util.Scanner;/**/
public class parserGrammarsFile{  public static void main(String args []) throws Exception  {    FileInputStream file = new FileInputStream("QBasicCodeFile.txt");    BufferedInputStream stream = new BufferedInputStream(file);    parserGrammarsFile parser = new parserGrammarsFile(stream);    AbstractNode rootSyntaxTree = BeginParsing();    rootSyntaxTree.execute(new Context());  }}PARSER_END(parserGrammarsFile)/* SKIP CHARACTERS */SKIP :{  " " | "\r" | "\t" }/* TOKENS OF ARITHMETIC OPERATORS */TOKEN : {    < PLUS :    "+"  | "-" >| < MULTIPLY :    "*"  | "/" >  | < POWER : "^" >| < DOL :"$" >| < #FLOATINGPOINT : "." < NUMBER > > }/* TOKENS OF STATEMENT */TOKEN : {  < PRINT : "PRINT" >| < INPUT : "INPUT" >| < THEN : " THEN " >| < IF : "IF" >| < ELSE : "ELSE " >| < END : "END" >| < WHILE : "WHILE" >| < WEND : "WEND" >}/* TOKENS OF DATA TYPE */TOKEN : {  < NUMBER : (< DIGIT >)+ >| < STRING : <  DOUBLEQUOTATION > ((< LETTER >) | (< DIGIT >) )* <  DOUBLEQUOTATION >>| < DOUBLE :    < NUMBER > (< FLOATINGPOINT >)?    (      (        "E"      | "e"      )      (        (          " + "        | " - "        )?      )      < NUMBER > (< FLOATINGPOINT >)?     )?>}/* TOKENS OF ALPHABET */TOKEN :{  < #DIGIT : [ "0"-"9" ] >| < #LETTER :  [ "a"-"z" ] | [ "A"-"Z" ] >}
/* SPECIAL TOKENS FOR QBasic LANGUAGE */TOKEN :{  < EOS : "\n" >| < ASSIGNMENT : "=" >| < EQ : < ASSIGNMENT > >| < LT : "<" >| < GT : ">" >| < LET : < LT > < EQ > >| < GET : < GT > < EQ > >| < NEQ : < LT > < GT > >| < OR : "OR">| < AND : "AND" >| < NOT : "NOT" >| < NEXT: "NEXT" >| < TO: "TO" >| < FOR: "FOR" >| < LOGICAL: < LT > | < GT > | "<=" | ">=" | "==" | "<>" | < ASSIGNMENT > >}/* TOKENS OF PUNCTUATION MARKS */TOKEN :{  < SINGLEQUOTATION : "\'">| < DOUBLEQUOTATION : "\"" >| < LP : "(" >| < RP : ")" >| < VARIABLE :    (      < LETTER >    )    (      < DIGIT >    | < LETTER >    | "_"    )* >}/**/RootParseTreeNode BeginParsing() :{  RootParseTreeNode rootParseTreeNode = new RootParseTreeNode();  AbstractNode childNode = null;}{  (    childNode = StatementGrammar(){      rootParseTreeNode.addChildToNode(childNode);    }  )*  {    return rootParseTreeNode;  }}/**/AbstractNode StatementGrammar() :{  AbstractNode abstractNode = null;}{  try {   (    LOOKAHEAD(2)    abstractNode = PrintGrammar()  | abstractNode = InputGrammar()  | abstractNode = AssignmentGrammar()  | abstractNode = IfGrammar()  | abstractNode = WhileGrammar()  | abstractNode = ForGrammar()  )	}	catch(ParseException e) {		System.out.println(e);		Token t;		do {		  t = getNextToken();		}while(t.kind!=EOS);	}  {    if(abstractNode == null)    	abstractNode = new RootParseTreeNode();    return abstractNode;  }}/**/PrintNode PrintGrammar() :{  PrintNode printNode = new PrintNode();  AbstractNode childNode = null;  Token token = new Token();}{  < PRINT > (    childNode = StringGrammar()   | childNode = ArithmeticExpressionGrammar()  ) < EOS >  {    printNode.addChildToNode(childNode);    return printNode;  }}/**/StringNode StringGrammar():{  Token token;}{  token = < STRING >  {    return new StringNode(token.image);  }}/**/ArithmeticExpressionNode ArithmeticExpressionGrammar() :// DONE{  ArithmeticExpressionNode rootArithmeticExpressionTree = new ArithmeticExpressionNode();//DONE  ArithmeticExpressionNode firstBranch = null;//DONE  ArithmeticExpressionNode secondBranch = null;//DONE  Token token = new Token();//DONE}{  firstBranch = MultiplicationGrammar()  (    token = < PLUS > secondBranch = ArithmeticExpressionGrammar()  )?  {    rootArithmeticExpressionTree.setOperation(token.image);//DONE    rootArithmeticExpressionTree.addChildToNode(firstBranch);//DONE    if (secondBranch != null)//DONE    {      rootArithmeticExpressionTree.addChildToNode(secondBranch);//DONE      return rootArithmeticExpressionTree;//DONE    }    else       return firstBranch;//DONE  }}/**/ArithmeticExpressionNode MultiplicationGrammar() : //Done{  ArithmeticExpressionNode rootMultiplicationTree = new ArithmeticExpressionNode(); //Done  ArithmeticExpressionNode firstBranch = null;//DONE  ArithmeticExpressionNode secondBranch = null;//DONE  Token token = new Token();//DONE}{  firstBranch = PowerGrammar() //Done  (    token = < MULTIPLY > secondBranch = MultiplicationGrammar() //Done  )?  {    rootMultiplicationTree.setOperation(token.image); //Done    rootMultiplicationTree.addChildToNode(firstBranch); //Done    if (secondBranch != null)//DONE    {      rootMultiplicationTree.addChildToNode(secondBranch); //Done      return rootMultiplicationTree; //Done    }    else       return firstBranch;//DONE  }}/**/ArithmeticExpressionNode PowerGrammar() ://Done{  ArithmeticExpressionNode rootPowerTree = new ArithmeticExpressionNode(); //Done  ArithmeticExpressionNode firstBranch = null;//DONE  ArithmeticExpressionNode secondBranch = null;//DONE  Token token = new Token();//DONE}{  firstBranch = PaketGrammar() //Done  (    token = < POWER > secondBranch = PowerGrammar() //Done  )?  {    rootPowerTree.setOperation(token.image); //Done    rootPowerTree.addChildToNode(firstBranch); //Done    if (secondBranch != null)//DONE    {      rootPowerTree.addChildToNode(secondBranch); //Done      return rootPowerTree; //Done    }    else       return firstBranch;//DONE  }}/**/ArithmeticExpressionNode PaketGrammar() : //Done{  ArithmeticExpressionNode rootPaketTree = new ArithmeticExpressionNode(); //Done  ArithmeticExpressionNode child = null;//Done  ConstantNode constNode = null;//Done  VariableNode varNode = null;//Done  Token token = new Token();//Done}{  (    LOOKAHEAD(2)    token = < DOUBLE >//DONE    {      constNode = new ConstantNode();//DONE      constNode.setValue(token.image);//DONE    }  |     token = < VARIABLE >//DONE    {      varNode = new VariableNode();//DONE      varNode.setVarId(token.image);//DONE    }  |     token = < NUMBER >//DONE    {      constNode = new ConstantNode();//DONE      constNode.setValue(token.image);//DONE    }  |    < LP > child = ArithmeticExpressionGrammar() < RP >//DONE  )  {    if (child != null)//DONE    {      return child;//DONE    }    else //DONE      if (varNode != null) //DONE        return varNode;//DONE      else //DONE        return constNode;//DONE  }}/**/AssignmentNode AssignmentGrammar() :{  Token tokenVar = null, tDol = null;  AssignmentNode assignmentNode = new AssignmentNode();  AbstractNode node = null;}{  tokenVar = < VARIABLE >  (   (     (        tDol = < DOL> < ASSIGNMENT > node = StringGrammar())     |     (       < ASSIGNMENT > node = ArithmeticExpressionGrammar())        )  ) < EOS >  {    if(tDol == null) {       assignmentNode.setvarId(tokenVar.image);    }else {       assignmentNode.setvarId(tokenVar.image );    }    assignmentNode.addChildToNode(node);    return assignmentNode;  }}/**/InputNode InputGrammar() :{  InputNode inputNode = new InputNode();  Token token;}{  < INPUT > token = < VARIABLE > < EOS >  {    inputNode.setVarName(token.image);    return inputNode;  }}/**/ConditionNode OrGrammar() :{  Token t = new Token();  ConditionNode cnode1 ,cnode2 = null;  OrNode node = new OrNode();  }{  cnode1  = AndGrammar()  (      < OR >  cnode2 = OrGrammar()  )?  {    if(cnode2 != null) {    	node.addChildToNode(cnode1);	    node.addChildToNode(cnode2);   		 return node; 	} 	else 		return cnode1;  }}/**/ConditionNode AndGrammar() :{  Token t = new Token();  ConditionNode cnode1 ,cnode2 = null;  AndNode node = new AndNode();  }{  cnode1  = NotGrammar()  (	< AND >  	cnode2 = AndGrammar()   )?   	  {    if(cnode2 != null) {    	node.addChildToNode(cnode1);	    node.addChildToNode(cnode2);   		 return node; 	} 	else 		return cnode1;  }}/**/ConditionNode NotGrammar() :{  Token t = null;  ConditionNode cnode1 ,cnode2 = null;  NotNode node = new NotNode(); }{  (	t = < NOT >  )?  cnode1  = ConditionGrammar()   	  {    if(t != null) {    	node.addChildToNode(cnode1);   		return node; 	} 	else 		return cnode1;  }}ConditionNode ConditionGrammar() :{  Token t = new Token();  ConditionNode cnode = new ConditionNode();  ConditionNode node1 = null;  ArithmeticExpressionNode enode1 = null;  ArithmeticExpressionNode enode2 = null;  StringNode enode11 = null;  StringNode enode22 = null;}{(  LOOKAHEAD(3)  (    < LP > node1 = OrGrammar() < RP >   )|    LOOKAHEAD(3)  (  enode1 = ArithmeticExpressionGrammar()  (    t = < EQ >  | t = < LT >  | t = < GT >  | t = < LET >  | t = < GET >  | t = < NEQ >  )  enode2 = ArithmeticExpressionGrammar()  )| LOOKAHEAD(3)(    (      enode11 = StringGrammar()	| t = < VARIABLE > { enode1 = new VariableNode(t.image);} 	)    (      t = < EQ >    | t = < NEQ >    )    (      enode22 = StringGrammar()	| t = < VARIABLE > { enode2 = new VariableNode(t.image);} 	)  ))  {    if(node1 != null)    	return node1;    if(enode1 != null) {      cnode.setOperation(t.image);      cnode.addChildToNode(enode1);      cnode.addChildToNode(enode2);    }    cnode.setOperation(t.image);    cnode.addChildToNode(enode11);    cnode.addChildToNode(enode22);    return cnode;  }}/***/IfNode IfGrammar():{ Token t1 = new Token(); IfNode ifNode = new IfNode(); ElseNode elseNode = new ElseNode(); ConditionNode conditionNode; RootParseTreeNode bnode1 = new RootParseTreeNode(); RootParseTreeNode bnode2 = null; AbstractNode abstractNode ;  } {   t1 = < IF > conditionNode = OrGrammar() < THEN > < EOS >   (     abstractNode = StatementGrammar()     {       bnode1.addChildToNode(abstractNode);     }   )*   (     < ELSE >< EOS >     {       bnode2 = new RootParseTreeNode();     }     (        abstractNode = StatementGrammar()     {        bnode2.addChildToNode(abstractNode);     }   )+   {     elseNode.addChildToNode(bnode2);   }   )?   (     < END >(<IF >)?   )?   < EOS >   {     ifNode.addChildToNode(conditionNode);     ifNode.addChildToNode(bnode1);     if(bnode2!=null)         ifNode.addChildToNode(elseNode);     return ifNode;   } }/**/WhileNode WhileGrammar() :{  WhileNode wnode = new WhileNode();  RootParseTreeNode bnode = new RootParseTreeNode();  AbstractNode n, s;}{  < WHILE > n = OrGrammar() < EOS >  (    s = StatementGrammar()    {      bnode.addChildToNode(s);    }  )*  < WEND >   {    wnode.addChildToNode(n);    wnode.addChildToNode(bnode);    return wnode;  }}/**/ForNode ForGrammar():{  ForNode res = new ForNode();  AbstractNode n1,n2,n3;  Token t;}{  < FOR > t= < VARIABLE > < ASSIGNMENT > n1 = ArithmeticExpressionGrammar()  < TO > n2 = ArithmeticExpressionGrammar() < EOS >  n3 = StatementGrammar()  (< EOS >)?  < NEXT > < VARIABLE > < EOS >    {    res.setVariable(t.image);    res.addChildToNode(n1);    res.addChildToNode(n2);    res.addChildToNode(n3);    return res;  }}